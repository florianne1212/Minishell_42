
qd on tape echo lolo > loulou tata, loulou est aussi pris en argument de echo

control C : on doit reafficher le prompt

base64 /dev/urandom | head -c 1000 | grep 42 | wc -l | sed -e 's/1/Yes/g' -e 's/0/No/g
le deuxieme -e de sed est pas bon

grep "libf" < loulou ok, par contre grep < loulou "libft" ne fonctionne pas car prend loulou en 1er qargument de grep

Pour fonction control
-une seule fonction qui recupere le numero devrait suffire, et on envoie a  $? 128 + n (enzo idea)
-ft_putstr_fd("\b\b  \b\b", 1); a mettre : permet d'effacer ce que le shell ecrit (^C ou ^\)
(merci enzo encore)

Pour le main et exit
-il faut comparer le premier arg a exit , ou exit\t et exit space
-Clean exit a faire en faisant des free pour toute la structure globale
-Ne pas oublier d'initialiser toute la structure globale en tout debut de programme

Dans lexline
mettre strlen en variable et appeler cette variable (accelere +++)
idem dans lex and parse

pourquoi a la fin de output on a index ++ dans putoutput

dans lexer d quote, dans join env, pour le retour, n'est ce pas *idx += 2 ?
dans join env n'y a t il pas des choses a free ?
en particulier dans
	str = ft_strjoin(str, s2);
le nouveau str n'est t-il pas malloque, avec perte du pointeur sur le str dans le join ?)

dans manage d quote
else if (c == '"' && (s[*idx - 1] != '\\'))
n'y a t-il pas de risque de buffer underflow (ie avoir s[-1]) ?

Dans init command, est ce que l'on ne fait pas un tableau de structure command et donc dans minishell.h , ne
faut il pas que t_command soit **cmd ?

//Dans lex and parse, apres init cmd, on a clean lexer (on l'efface ?)

dans parser
	break

Interrogations
- control + D : envoie EOF, ce qui vient faire chier notre get next line qui sert a recuperer la ligne de commande
il faut donc quand gnl renvoie 0 etre sur que c'est bien la fin de notre ligne et non pas le control +c
(aucune, mais aucune idee de comment faire.....)

-Fork : apparement il faut fork potentiellement plusieurs choses a la fois (bash lance plusieurs processus en meme temps)
mais d'un autre cote, il ne faut pas que l'invite de commande arrive trop vient
apparemment il aut utiliser waitfid avec -1 en premier param, faut il utiliser les autres param ? a voir

- Les pipes : a priori il faut creer 2 pipes : un pour le fils pour lui amener les infos, un pour renvoyer les infos au pere
dans le pere et le fils , il faut fermet le bout de tuyau qui ne sert pas, et lier le bon bout de tuyau a stdin et stdout